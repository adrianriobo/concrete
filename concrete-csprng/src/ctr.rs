use super::AesKey;
use crate::{aesni, software};
use std::cmp::Ordering;

/// A trait for batched generators, i.e. generators that creates 128 bytes of random values at a
/// time.
pub trait AesBatchedGenerator: Clone {
    /// Instantiate a new generator from a secret key.
    fn new(key: Option<AesKey>) -> Self;
    /// Generates the batch corresponding to the given counter.
    fn generate_batch(&mut self, ctr: AesCtr) -> AesBatch;
}

pub type AesBatch = [u8; 128];

/// Represents the counter used by the AES block cipher to generate a set of values.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct AesCtr(pub u128);

/// Represents the counter used to index on the batch-generated bytes.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct ByteCtr(pub u8);

/// Whether the next `increment` call will need a new batch of values or not.
pub(crate) enum ShouldGenerateBatch {
    GenerateBatch,
    Wait,
}

/// A state that uniquely defines the next byte outputted by a given `AesCtrGenerator`.
///
/// To construct a generator that can yield a byte at each call to `generate_next`, we must be
/// able to store both the last AES counter used, and the index of the last outputted byte in the
/// batch. This structure contains both, and provides operations to manipulate those two values
/// correctly.
#[derive(Debug, Clone)]
pub struct State {
    aes_ctr: AesCtr,
    byte_ctr: ByteCtr,
}

impl State {
    /// Generates a new state from an AES counter value.
    pub fn from_aes_counter(ctr: AesCtr) -> Self {
        State {
            aes_ctr: ctr,
            byte_ctr: ByteCtr(0),
        }
    }

    /// A batch of values spans multiple values of the AES counter. Meaning that the same state
    /// can have different representations in practice. For instance: (1, 56) == (4, 8) since
    /// 1 * 16 + 56 == 4 * 16 + 8. For this reason, it is easier to manipulate those in a
    /// normalized form, where the byte counter is minimized, and the aes counter is maximized.
    pub(crate) fn normalize(&self) -> Self {
        let State {
            aes_ctr: AesCtr(aes_ctr),
            byte_ctr: ByteCtr(byte_ctr),
        } = self;
        let aes_ctr = aes_ctr + (byte_ctr / 16) as u128;
        let byte_ctr = byte_ctr % 16;
        State {
            aes_ctr: AesCtr(aes_ctr),
            byte_ctr: ByteCtr(byte_ctr),
        }
    }

    /// Returns the successor of the current state.
    pub fn successor(&self) -> Self {
        let State {
            byte_ctr: ByteCtr(byte_ctr),
            aes_ctr: AesCtr(aes_ctr),
        } = self;
        if *byte_ctr < 127 {
            State {
                aes_ctr: AesCtr(*aes_ctr),
                byte_ctr: ByteCtr(byte_ctr + 1),
            }
        } else {
            State {
                aes_ctr: AesCtr(*aes_ctr + 8),
                byte_ctr: ByteCtr(0),
            }
        }
    }

    /// Returns the byte counter.
    pub fn get_byte_counter(&self) -> ByteCtr {
        self.byte_ctr
    }

    /// Returns the aes counter.
    pub fn get_aes_counter(&self) -> AesCtr {
        self.aes_ctr
    }

    pub(crate) fn get_batch_index(&self) -> usize {
        self.byte_ctr.0 as usize
    }

    pub(crate) fn increment(&mut self) -> ShouldGenerateBatch {
        let State {
            aes_ctr: AesCtr(ref mut aes_ctr),
            byte_ctr: ByteCtr(ref mut byte_ctr),
        } = self;
        if *byte_ctr < 127 {
            *byte_ctr += 1;
            ShouldGenerateBatch::Wait
        } else {
            *aes_ctr += 8;
            *byte_ctr = 0;
            ShouldGenerateBatch::GenerateBatch
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new(aes_ctr: u128, byte_ctr: u8) -> Self {
        debug_assert!(byte_ctr <= 127);
        State {
            aes_ctr: AesCtr(aes_ctr),
            byte_ctr: ByteCtr(byte_ctr),
        }
    }

    pub(crate) fn shift(&mut self, n_bytes: usize) -> ShouldGenerateBatch {
        let State {
            aes_ctr: AesCtr(ref mut aes_ctr),
            byte_ctr: ByteCtr(ref mut byte_ctr),
        } = self;
        let n_bytes = n_bytes + (*byte_ctr as usize);
        let aes_bump = ((n_bytes / 128) as u128) * 8;
        *byte_ctr = (n_bytes % 128) as u8;
        if aes_bump > 0 {
            *aes_ctr += aes_bump;
            ShouldGenerateBatch::GenerateBatch
        } else {
            ShouldGenerateBatch::Wait
        }
    }
}

impl PartialEq for State {
    fn eq(&self, other: &Self) -> bool {
        let self_norm = self.normalize();
        let other_norm = other.normalize();
        self_norm.aes_ctr == other_norm.aes_ctr && self_norm.byte_ctr == other_norm.byte_ctr
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        let self_norm = self.normalize();
        let other_norm = other.normalize();
        if self_norm.aes_ctr < other_norm.aes_ctr {
            Some(Ordering::Less)
        } else if self_norm.aes_ctr > other_norm.aes_ctr {
            Some(Ordering::Greater)
        } else if self_norm.byte_ctr < other_norm.byte_ctr {
            Some(Ordering::Less)
        } else if self_norm.byte_ctr > other_norm.byte_ctr {
            Some(Ordering::Greater)
        } else {
            Some(Ordering::Equal)
        }
    }
}

impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl Eq for State {}

impl Default for State {
    fn default() -> Self {
        State {
            aes_ctr: AesCtr(0),
            byte_ctr: ByteCtr(0),
        }
    }
}

/// A generator that uses the software implementation.
pub type SoftAesCtrGenerator = AesCtrGenerator<software::Generator>;

/// A generator that uses the hardware implementation.
pub type HardAesCtrGenerator = AesCtrGenerator<aesni::Generator>;

/// A csprng which operates in batch mode.
#[derive(Clone)]
pub struct AesCtrGenerator<G: AesBatchedGenerator> {
    generator: G,
    state: State,
    bound: Option<State>,
    batch: AesBatch
}

impl<G: AesBatchedGenerator> AesCtrGenerator<G> {
    /// Generates a new csprng.
    ///
    /// If not given, the key is automatically selected, and the state is set to zero.
    pub fn new(
        key: Option<AesKey>,
        state: Option<State>,
        bound: Option<State>,
    ) -> AesCtrGenerator<G> {
        let mut generator = G::new(key);
        let state = state.unwrap_or_default();
        if let Some(ref actual_bound) = bound {
            debug_assert!(state <= *actual_bound);
        }
        let batch = generator.generate_batch(state.aes_ctr);
        AesCtrGenerator {
            generator,
            state,
            bound,
            batch,
        }
    }

    /// Returns the state of the current generator.
    pub fn get_state(&self) -> &State {
        &self.state
    }

    /// Returns the bound of the generator if any.
    pub fn get_bound(&self) -> Option<&State> {
        self.bound.as_ref()
    }

    /// Returns whether the generator is bounded.
    pub fn is_bounded(&self) -> bool {
        self.bound.is_some()
    }

    /// Yields the next random byte.
    ///
    /// # Panics:
    ///
    /// If the generator is bounded and the bound is reached, it will panic. Note that the bound
    /// checking can be removed using the `unchecked` feature.
    pub fn generate_next(&mut self) -> u8 {
        let output = self.batch[self.state.get_batch_index()];
        #[cfg(not(feature = "unchecked"))]
        {
            if self
                .bound
                .as_ref()
                .map_or(false, |bound| self.state >= *bound)
            {
                panic!("Tried to generate a byte outside the generator bound.");
            }
        }
        match self.state.increment() {
            ShouldGenerateBatch::GenerateBatch => {
                self.batch = self.generator.generate_batch(self.state.get_aes_counter());
            }
            ShouldGenerateBatch::Wait => {}
        }
        output
    }

    /// Tries to fork the current generator into `n_child` generators each able to yield
    /// `child_bytes` random bytes.
    ///
    /// If the total number of bytes to be generated exceeds the bound of the current generator,
    /// `None` is returned. Otherwise, we return an iterator over the children generators.
    pub fn try_fork(
        &mut self,
        n_child: ChildCount,
        child_bytes: BytesPerChild,
    ) -> Option<impl Iterator<Item = AesCtrGenerator<G>>> {
        // Check that we don't overshoot the bound
        if let Some(ref actual_bound) = self.bound {
            let mut end = self.state.clone();
            end.shift(n_child.0 * child_bytes.0);
            if end > *actual_bound {
                return None;
            }
        }
        let state = self.state.clone();
        let generator = self.generator.clone();
        let output = (0..n_child.0).map(move |i| {
            let mut new_state = state.clone();
            new_state.shift(child_bytes.0 * i);
            let mut new_bound = new_state.clone();
            new_bound.shift(child_bytes.0);
            let mut new_generator = generator.clone();
            let batch = new_generator.generate_batch(new_state.aes_ctr);
            AesCtrGenerator {
                generator: new_generator,
                state: new_state,
                bound: Some(new_bound),
                batch
            }
        });
        let generate = self.state.shift(child_bytes.0 * n_child.0);
        if let ShouldGenerateBatch::GenerateBatch = generate {
            self.batch = self.generator.generate_batch(self.state.get_aes_counter());
        }
        Some(output)
    }
}

/// The number of children created when a generator is forked.
#[derive(Debug, Copy, Clone)]
pub struct ChildCount(pub usize);

/// The number of bytes each children can generate, when a generator is forked.
#[derive(Debug, Copy, Clone)]
pub struct BytesPerChild(pub usize);

#[cfg(test)]
mod test {
    use super::*;
    use crate::AesKey;
    use rand;
    use rand::Rng;

    #[test]
    fn test_gen_byte_incr() {
        // Checks that the byte counter is correctly incremented.
        for _ in 0..1000 {
            let state = rand::thread_rng().gen::<u128>();
            let mut a = SoftAesCtrGenerator::new(
                Some(AesKey(0)),
                Some(State::from_aes_counter(AesCtr(state))),
                None,
            );
            assert_eq!(
                *a.get_state(),
                State {
                    aes_ctr: AesCtr(state),
                    byte_ctr: ByteCtr(0),
                }
            );
            a.generate_next();
            assert_eq!(
                *a.get_state(),
                State {
                    aes_ctr: AesCtr(state),
                    byte_ctr: ByteCtr(1),
                }
            );
        }
    }

    #[test]
    fn test_gen_aes_incr() {
        // Checks that the aes counter is correctly incremented.
        for _ in 0..1000 {
            let state = rand::thread_rng().gen::<u128>();
            let mut a = SoftAesCtrGenerator::new(
                Some(AesKey(0)),
                Some(State::from_aes_counter(AesCtr(state))),
                None,
            );
            assert_eq!(
                *a.get_state(),
                State {
                    aes_ctr: AesCtr(state),
                    byte_ctr: ByteCtr(0),
                }
            );
            for _ in 0..127 {
                a.generate_next();
            }
            assert_eq!(
                *a.get_state(),
                State {
                    aes_ctr: AesCtr(state),
                    byte_ctr: ByteCtr(127),
                }
            );
            a.generate_next();
            assert_eq!(
                *a.get_state(),
                State {
                    aes_ctr: AesCtr(state.wrapping_add(8)),
                    byte_ctr: ByteCtr(0),
                }
            );
        }
    }

    #[test]
    fn test_normalization_generation() {
        // Checks that normalizing a state does not affect the output.
        for _ in 0..1000 {
            let key = AesKey(rand::thread_rng().gen());
            let mut a = SoftAesCtrGenerator::new(Some(key), None, None);
            for _ in 0..rand::thread_rng().gen::<u16>() {
                a.generate_next();
            }
            let norm_state = a.get_state().normalize();
            let mut b = SoftAesCtrGenerator::new(Some(key), Some(norm_state), None);
            assert_eq!(a.generate_next(), b.generate_next());
        }
    }

    #[test]
    fn test_state_fork_initial_batch() {
        // Checks that forking the prng into children that spawns the initial batch gives the
        // correct states.
        let state = State::from_aes_counter(AesCtr(0));
        let mut generator = SoftAesCtrGenerator::new(None, Some(state), None);
        assert_eq!(*generator.get_state(), State::new(0, 0));
        let children: Vec<_> = generator
            .try_fork(ChildCount(2), BytesPerChild(3))
            .unwrap()
            .collect();
        assert_eq!(*generator.get_state(), State::new(0, 6));
        let mut first = children.get(0).unwrap().clone();
        assert_eq!(*first.get_state(), State::new(0, 0));
        assert_eq!(*first.get_bound().unwrap(), State::new(0, 3));
        let out_first: Vec<_> = first
            .try_fork(ChildCount(3), BytesPerChild(1))
            .unwrap()
            .collect();
        assert_eq!(*first.get_state(), State::new(0, 3));
        assert_eq!(*first.get_bound().unwrap(), State::new(0, 3));
        let first_first = out_first.get(0).unwrap();
        assert_eq!(*first_first.get_state(), State::new(0, 0));
        assert_eq!(*first_first.get_bound().unwrap(), State::new(0, 1));
        let first_second = out_first.get(1).unwrap();
        assert_eq!(*first_second.get_state(), State::new(0, 1));
        assert_eq!(*first_second.get_bound().unwrap(), State::new(0, 2));
        let first_third = out_first.get(2).unwrap();
        assert_eq!(*first_third.get_state(), State::new(0, 2));
        assert_eq!(*first_third.get_bound().unwrap(), State::new(0, 3));
        let second = children.get(1).unwrap();
        assert_eq!(*second.get_state(), State::new(0, 3));
        assert_eq!(*second.get_bound().unwrap(), State::new(0, 6));
    }

    #[test]
    fn test_state_fork_next_batch() {
        // Checks that forking the prng into children that spawns the next batch gives the
        // correct states.
        let state = State::from_aes_counter(AesCtr(0));
        let mut generator = SoftAesCtrGenerator::new(None, Some(state), None);
        assert_eq!(*generator.get_state(), State::new(0, 0));
        let out: Vec<_> = generator
            .try_fork(ChildCount(4), BytesPerChild(127))
            .unwrap()
            .collect();
        assert_eq!(*generator.get_state(), State::new(24, 124));
        let mut first = out.get(0).unwrap().clone();
        assert_eq!(*first.get_state(), State::new(0, 0));
        assert_eq!(*first.get_bound().unwrap(), State::new(0, 127));
        let out_first: Vec<_> = first
            .try_fork(ChildCount(3), BytesPerChild(1))
            .unwrap()
            .collect();
        assert_eq!(*first.get_state(), State::new(0, 3));
        assert_eq!(*first.get_bound().unwrap(), State::new(0, 127));
        let first_first = out_first.get(0).unwrap();
        assert_eq!(*first_first.get_state(), State::new(0, 0));
        assert_eq!(*first_first.get_bound().unwrap(), State::new(0, 1));
        let first_second = out_first.get(1).unwrap();
        assert_eq!(*first_second.get_state(), State::new(0, 1));
        assert_eq!(*first_second.get_bound().unwrap(), State::new(0, 2));
        let first_third = out_first.get(2).unwrap();
        assert_eq!(*first_third.get_state(), State::new(0, 2));
        assert_eq!(*first_third.get_bound().unwrap(), State::new(0, 3));
        let second = out.get(1).unwrap();
        assert_eq!(*second.get_state(), State::new(0, 127));
        assert_eq!(*second.get_bound().unwrap(), State::new(8, 126));
    }

    #[test]
    fn test_state_ordering() {
        // Checks that state ordering is correct.
        let first = State::new(1, 56);
        let second = State::new(1, 56);
        assert_eq!(first, second);
        let first = State::new(1, 56);
        let second = State::new(1, 55);
        assert!(first > second);
        let first = State::new(1, 56);
        let second = State::new(1, 57);
        assert!(first < second);
        let first = State::new(1, 127);
        let second = State::new(9, 0);
        assert!(first < second);
        let first = State::new(1, 56);
        let second = State::new(4, 8);
        assert_eq!(first, second);
        let first = State::new(1, 56);
        let second = State::new(4, 7);
        assert!(second < first);
        let first = State::new(1, 57);
        let second = State::new(4, 8);
        assert!(second < first);
        let first = State::new(1, 55);
        let second = State::new(4, 8);
        assert!(second > first);
        let first = State::new(1, 56);
        let second = State::new(4, 9);
        assert!(second > first);
    }

    #[test]
    fn test_randomized_fork_generation() {
        // Checks that whatever the fork, whatever the state, children generate the same outputs
        // sequence as parent, and that parent recover at the proper position.
        for _ in 0..100 {
            let state = State::from_aes_counter(AesCtr(rand::thread_rng().gen()));
            let n_child = ChildCount(rand::thread_rng().gen::<usize>() % 200);
            let bytes_child = BytesPerChild(rand::thread_rng().gen::<usize>() % 200);
            let key = AesKey(rand::thread_rng().gen());
            let mut generator =
                SoftAesCtrGenerator::new(Some(key.clone()), Some(state.clone()), None);
            let n_to_gen = n_child.0 * bytes_child.0;
            let initial_output: Vec<u8> =
                (0..n_to_gen).map(|_| generator.generate_next()).collect();
            let mut forking_generator = SoftAesCtrGenerator::new(Some(key), Some(state), None);
            let children_output: Vec<u8> = forking_generator
                .try_fork(n_child, bytes_child)
                .unwrap()
                .map(|mut child| (0..bytes_child.0).map(move |_| child.generate_next()))
                .flatten()
                .collect();
            assert_eq!(initial_output, children_output);
            assert_eq!(forking_generator.generate_next(), generator.generate_next());
        }
    }
}
